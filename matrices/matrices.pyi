import sys
from collections.abc import Callable, Collection, Iterable, Iterator, Sequence
from enum import Enum
from typing import (Any, Literal, Optional, SupportsIndex, TypeVar, final,
                    overload)

from .types import Complex, Real, SupportsComparison

T = TypeVar("T")
S = TypeVar("S")

SupportsComparisonT = TypeVar("SupportsComparisonT", bound=SupportsComparison)


@final
class Rule(Enum):

    ROW: int
    COL: int

    @property
    def inverse(self) -> Rule: ...
    @property
    def true_name(self) -> Literal["row", "column"]: ...

    def subshape(self, shape: Shape) -> Shape: ...
    def serialize(self, index: int, shape: Shape) -> tuple[int, int, int]: ...
    def range(self, index: int, shape: Shape) -> range: ...
    def slice(self, index: int, shape: Shape) -> slice: ...

    def __index__(self) -> int: ...
    def __invert__(self) -> Rule: ...


@final
class Shape(Collection[int]):

    @property
    def data(self) -> list[int]: ...
    @property
    def nrows(self) -> int: ...
    @nrows.setter
    def nrows(self, value: int) -> None: ...
    @property
    def ncols(self) -> int: ...
    @ncols.setter
    def ncols(self, value: int) -> None: ...
    @property
    def size(self) -> int: ...

    def copy(self) -> Shape: ...
    def reverse(self) -> Shape: ...
    def resolve_index(self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def resolve_slice(self, key: slice, *, by: Rule = Rule.ROW) -> range: ...

    def __init__(self, nrows: int = 0, ncols: int = 0) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __getitem__(self, key: SupportsIndex) -> int: ...
    def __setitem__(self, key: SupportsIndex, value: int) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __and__(self, other: Shape) -> bool: ...
    def __rand__(self, other: Shape) -> bool: ...
    def __copy__(self) -> Shape: ...
    def __deepcopy__(self, memo: Optional[dict[int, Any]] = None) -> Shape: ...


class ShapeError(ValueError):
    pass


GenericMatrixT = TypeVar("GenericMatrixT", bound=GenericMatrix)

class GenericMatrix(Sequence[T]):

    @classmethod
    def wrap(cls: type[GenericMatrixT], data: list[T], shape: Shape) -> GenericMatrixT: ...
    @classmethod
    def fill(cls: type[GenericMatrixT], value: T, nrows: int, ncols: int) -> GenericMatrixT: ...
    @classmethod
    def refer(cls: type[GenericMatrixT], other: GenericMatrix[T]) -> GenericMatrixT: ...
    @classmethod
    def infer(cls: type[GenericMatrixT], other: Iterable[Iterable[T]]) -> GenericMatrixT: ...

    @property
    def data(self: GenericMatrixT) -> list[T]: ...
    @property
    def shape(self: GenericMatrixT) -> Shape: ...
    @property
    def size(self: GenericMatrixT) -> int: ...
    @property
    def nrows(self: GenericMatrixT) -> int: ...
    @property
    def ncols(self: GenericMatrixT) -> int: ...

    def index(self: GenericMatrixT, value: T, start: int = 0, stop: Optional[int] = None) -> int: ...
    def count(self: GenericMatrixT, value: T) -> int: ...
    def reshape(self: GenericMatrixT, nrows: int, ncols: int) -> GenericMatrixT: ...
    def slices(self: GenericMatrixT, *, by: Rule = Rule.ROW) -> Iterator[GenericMatrixT]: ...
    def mask(self: GenericMatrixT, selector: GenericMatrix, null: T) -> GenericMatrixT: ...
    def replace(self: GenericMatrixT, old: T, new: T, *, times: Optional[int] = None) -> GenericMatrixT: ...
    def reverse(self: GenericMatrixT) -> GenericMatrixT: ...
    def swap(self: GenericMatrixT, key1: SupportsIndex, key2: SupportsIndex, *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def flip(self: GenericMatrixT, *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def flatten(self: GenericMatrixT, *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def transpose(self: GenericMatrixT) -> GenericMatrixT: ...
    def stack(self: GenericMatrixT, other: GenericMatrix[T], *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def pull(self: GenericMatrixT, key: SupportsIndex = -1, *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def copy(self: GenericMatrixT, *, deep: bool = False) -> GenericMatrixT: ...

    def __init__(self: GenericMatrixT, values: Iterable[T], nrows: int, ncols: int) -> None: ...
    def __repr__(self: GenericMatrixT) -> str: ...
    def __str__(self: GenericMatrixT) -> str: ...

    # By returning a RealMatrix, we're expecting the elements to return
    # booleans in their implementation of __eq__() and __ne__(). This is
    # conventional, and lightly enforced by built-in object. Returning other
    # things is uncommon enough to the point where I think it'll be safe.

    # The logical operators &, |, ^, and ~, guarantee boolean results due to
    # their functional implementation found in utilities.py.

    def __eq__(self: GenericMatrixT, other: GenericMatrix) -> RealMatrix: ...  # type: ignore[override]
    def __ne__(self: GenericMatrixT, other: GenericMatrix) -> RealMatrix: ...  # type: ignore[override]

    def __and__(self: GenericMatrixT, other: GenericMatrix) -> RealMatrix: ...
    def __xor__(self: GenericMatrixT, other: GenericMatrix) -> RealMatrix: ...
    def __or__(self: GenericMatrixT, other: GenericMatrix) -> RealMatrix: ...

    def __rand__(self: GenericMatrixT, other: GenericMatrix) -> RealMatrix: ...
    def __rxor__(self: GenericMatrixT, other: GenericMatrix) -> RealMatrix: ...
    def __ror__(self: GenericMatrixT, other: GenericMatrix) -> RealMatrix: ...

    def __invert__(self: GenericMatrixT) -> RealMatrix: ...

    @overload
    def __getitem__(self: GenericMatrixT, key: SupportsIndex) -> T: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: slice) -> GenericMatrixT: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: tuple[SupportsIndex, SupportsIndex]) -> T: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: tuple[SupportsIndex, slice]) -> GenericMatrixT: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: tuple[slice, SupportsIndex]) -> GenericMatrixT: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: tuple[slice, slice]) -> GenericMatrixT: ...

    @overload
    def __setitem__(self: GenericMatrixT, key: SupportsIndex, other: T) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: slice, other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: tuple[SupportsIndex, SupportsIndex], other: T) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: tuple[SupportsIndex, slice], other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: tuple[slice, SupportsIndex], other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: tuple[slice, slice], other: GenericMatrix[T]) -> None: ...

    def __len__(self: GenericMatrixT) -> int: ...
    def __iter__(self: GenericMatrixT) -> Iterator[T]: ...
    def __reversed__(self: GenericMatrixT) -> Iterator[T]: ...
    def __contains__(self: GenericMatrixT, value: Any) -> bool: ...
    def __copy__(self: GenericMatrixT) -> GenericMatrixT: ...
    def __deepcopy__(self: GenericMatrixT, memo: Optional[dict[int, Any]] = None) -> GenericMatrixT: ...


OrderingMatrixT = TypeVar("OrderingMatrixT", bound=OrderingMatrix)

class OrderingMatrix(GenericMatrix[SupportsComparisonT]):

    # Like with __eq__() and __ne__(), we're assuming that the contained type
    # returns boolean values in its comparison overloads. Again, common enough
    # that it should be safe.

    def __lt__(self: OrderingMatrixT, other: GenericMatrix) -> RealMatrix: ...
    def __gt__(self: OrderingMatrixT, other: GenericMatrix) -> RealMatrix: ...
    def __le__(self: OrderingMatrixT, other: GenericMatrix) -> RealMatrix: ...
    def __ge__(self: OrderingMatrixT, other: GenericMatrix) -> RealMatrix: ...


CallableMatrixT = TypeVar("CallableMatrixT", bound=CallableMatrix)

if sys.version_info >= (3, 10):
    from typing import ParamSpec

    P = ParamSpec("P")

    # Mypy thinks there's an error in this ParamSpec usage, but will still
    # infer everything correctly - don't know what's going on with that
    class CallableMatrix(GenericMatrix[Callable[P, T]]):  # type: ignore[misc]

        def __call__(self: CallableMatrixT, *args: P.args, **kwargs: P.kwargs) -> GenericMatrix[T]: ...

else:

    class CallableMatrix(GenericMatrix[Callable[..., T]]):

        def __call__(self: CallableMatrixT, *args: Any, **kwargs: Any) -> GenericMatrix[T]: ...


ComplexMatrixT = TypeVar("ComplexMatrixT", bound=ComplexMatrix)

class ComplexMatrix(GenericMatrix[Complex]):

    @classmethod
    def identity(cls: type[ComplexMatrixT], n: int) -> ComplexMatrixT: ...

    def norm(self: ComplexMatrixT) -> Real: ...
    def dot(self: ComplexMatrixT, other: ComplexMatrix) -> Complex: ...

    def abs(self: ComplexMatrixT) -> RealMatrix: ...
    def conjugate(self: ComplexMatrixT) -> ComplexMatrix: ...

    @overload
    def __add__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __add__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __sub__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __sub__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __mul__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __mul__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __truediv__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __truediv__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __pow__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __pow__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...

    @overload
    def __radd__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __radd__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __rsub__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __rsub__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __rmul__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __rmul__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __rtruediv__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __rtruediv__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __rpow__(self: ComplexMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __rpow__(self: ComplexMatrixT, other: GenericMatrix) -> GenericMatrix: ...

    def __neg__(self: ComplexMatrixT) -> ComplexMatrix: ...
    def __pos__(self: ComplexMatrixT) -> ComplexMatrix: ...


RealMatrixT = TypeVar("RealMatrixT", bound=RealMatrix)

class RealMatrix(OrderingMatrix[Real], ComplexMatrix):

    def trunc(self: RealMatrixT) -> RealMatrix: ...
    def floor(self: RealMatrixT) -> RealMatrix: ...
    def ceil(self: RealMatrixT) -> RealMatrix: ...
    @overload
    def round(self: RealMatrixT) -> RealMatrix: ...
    @overload
    def round(self: RealMatrixT, ndigits: SupportsIndex) -> RealMatrix: ...

    @overload
    def __floordiv__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __floordiv__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __mod__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __mod__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...

    @overload
    def __rfloordiv__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __rfloordiv__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload
    def __rmod__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __rmod__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...

    @overload
    def dot(self: RealMatrixT, other: RealMatrix) -> Real: ...
    @overload
    def dot(self: RealMatrixT, other: ComplexMatrix) -> Complex: ...

    def conjugate(self: RealMatrixT) -> RealMatrix: ...

    @overload  # type: ignore[override]
    def __add__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __add__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __add__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload  # type: ignore[override]
    def __sub__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __sub__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __sub__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload  # type: ignore[override]
    def __mul__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __mul__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __mul__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload  # type: ignore[override]
    def __truediv__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __truediv__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __truediv__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload  # type: ignore[override]
    def __pow__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __pow__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __pow__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...

    @overload  # type: ignore[override]
    def __radd__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __radd__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __radd__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload  # type: ignore[override]
    def __rsub__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __rsub__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __rsub__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload  # type: ignore[override]
    def __rmul__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __rmul__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __rmul__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload  # type: ignore[override]
    def __rtruediv__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __rtruediv__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __rtruediv__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...
    @overload  # type: ignore[override]
    def __rpow__(self: RealMatrixT, other: RealMatrix) -> RealMatrix: ...
    @overload
    def __rpow__(self: RealMatrixT, other: ComplexMatrix) -> ComplexMatrix: ...
    @overload
    def __rpow__(self: RealMatrixT, other: GenericMatrix) -> GenericMatrix: ...

    def __neg__(self: RealMatrixT) -> RealMatrix: ...
    def __pos__(self: RealMatrixT) -> RealMatrix: ...
