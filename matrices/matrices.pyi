import sys
import typing
from collections.abc import Callable, Collection, Iterable, Iterator, Sequence
from enum import Enum
from typing import Any, Literal, Optional, SupportsIndex, TypeVar

from .types import Complex, Real, SupportsComparison

T = TypeVar("T")
S = TypeVar("S")

SupportsComparisonT = TypeVar("SupportsComparisonT", bound=SupportsComparison)
ComplexT = TypeVar("ComplexT", bound=Complex)
RealT = TypeVar("RealT", bound=Real)


@typing.final
class Rule(Enum):

    ROW: int
    COL: int

    @property
    def inverse(self) -> Rule: ...
    @property
    def true_name(self) -> Literal["row", "column"]: ...

    def subshape(self, shape: Shape) -> Shape: ...
    def serialize(self, index: int, shape: Shape) -> tuple[int, int, int]: ...
    def range(self, index: int, shape: Shape) -> range: ...
    def slice(self, index: int, shape: Shape) -> slice: ...

    def __index__(self) -> int: ...
    def __invert__(self) -> Rule: ...


@typing.final
class Shape(Collection[int]):

    @property
    def data(self) -> list[int]: ...
    @property
    def nrows(self) -> int: ...
    @nrows.setter
    def nrows(self, value: int) -> None: ...
    @property
    def ncols(self) -> int: ...
    @ncols.setter
    def ncols(self, value: int) -> None: ...
    @property
    def size(self) -> int: ...

    def copy(self) -> Shape: ...
    def reverse(self) -> Shape: ...
    def resolve_index(self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def resolve_slice(self, key: slice, *, by: Rule = Rule.ROW) -> range: ...

    def __init__(self, nrows: int = 0, ncols: int = 0) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __getitem__(self, key: SupportsIndex) -> int: ...
    def __setitem__(self, key: SupportsIndex, value: int) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __and__(self, other: Shape) -> bool: ...
    def __rand__(self, other: Shape) -> bool: ...
    def __copy__(self) -> Shape: ...
    def __deepcopy__(self, memo: Optional[dict[int, Any]] = None) -> Shape: ...


class ShapeError(ValueError):
    pass


class GenericMatrix(Sequence[T]):
    if sys.version_info >= (3, 11):
        Self = typing.Self
    else:
        Self = TypeVar("Self", bound="GenericMatrix")

    @classmethod
    def wrap(cls: type[Self], data: list[T], shape: Shape) -> Self: ...
    @classmethod
    def fill(cls: type[Self], value: T, nrows: int, ncols: int) -> Self: ...
    @classmethod
    def refer(cls: type[Self], other: GenericMatrix[T]) -> Self: ...
    @classmethod
    def infer(cls: type[Self], other: Iterable[Iterable[T]]) -> Self: ...

    @property
    def data(self: Self) -> list[T]: ...
    @property
    def shape(self: Self) -> Shape: ...
    @property
    def size(self: Self) -> int: ...
    @property
    def nrows(self: Self) -> int: ...
    @property
    def ncols(self: Self) -> int: ...

    def index(self: Self, value: T, start: int = 0, stop: Optional[int] = None) -> int: ...
    def count(self: Self, value: T) -> int: ...
    def reshape(self: Self, nrows: int, ncols: int) -> Self: ...
    def slices(self: Self, *, by: Rule = Rule.ROW) -> Iterator[Self]: ...
    def mask(self: Self, selector: GenericMatrix, null: T) -> Self: ...
    def replace(self: Self, old: T, new: T, *, times: Optional[int] = None) -> Self: ...
    def reverse(self: Self) -> Self: ...
    def swap(self: Self, key1: SupportsIndex, key2: SupportsIndex, *, by: Rule = Rule.ROW) -> Self: ...
    def flip(self: Self, *, by: Rule = Rule.ROW) -> Self: ...
    def flatten(self: Self, *, by: Rule = Rule.ROW) -> Self: ...
    def transpose(self: Self) -> Self: ...
    def stack(self: Self, other: GenericMatrix[T], *, by: Rule = Rule.ROW) -> Self: ...
    def pull(self: Self, key: SupportsIndex = -1, *, by: Rule = Rule.ROW) -> Self: ...
    def copy(self: Self, *, deep: bool = False) -> Self: ...

    def __init__(self: Self, values: Iterable[T], nrows: int, ncols: int) -> None: ...
    def __repr__(self: Self) -> str: ...
    def __str__(self: Self) -> str: ...

    # By returning a RealMatrix[bool], we're expecting the elements to return
    # booleans in their implementation of __eq__() and __ne__(). This is
    # conventional, and lightly enforced by built-in object. Returning other
    # things is uncommon enough to the point where I think it'll be safe.

    # The logical operators &, |, ^, and ~, guarantee boolean results due to
    # their functional implementation found in utilities.py.

    def __eq__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...  # type: ignore[override]
    def __ne__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...  # type: ignore[override]

    def __and__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...
    def __xor__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...
    def __or__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...

    def __rand__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...
    def __rxor__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...
    def __ror__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...

    def __invert__(self: Self) -> "RealMatrix[bool]": ...

    @typing.overload
    def __getitem__(self: Self, key: SupportsIndex) -> T: ...
    @typing.overload
    def __getitem__(self: Self, key: slice) -> Self: ...
    @typing.overload
    def __getitem__(self: Self, key: tuple[SupportsIndex, SupportsIndex]) -> T: ...
    @typing.overload
    def __getitem__(self: Self, key: tuple[SupportsIndex, slice]) -> Self: ...
    @typing.overload
    def __getitem__(self: Self, key: tuple[slice, SupportsIndex]) -> Self: ...
    @typing.overload
    def __getitem__(self: Self, key: tuple[slice, slice]) -> Self: ...

    @typing.overload
    def __setitem__(self: Self, key: SupportsIndex, other: T) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: slice, other: GenericMatrix[T]) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: tuple[SupportsIndex, SupportsIndex], other: T) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: tuple[SupportsIndex, slice], other: GenericMatrix[T]) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: tuple[slice, SupportsIndex], other: GenericMatrix[T]) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: tuple[slice, slice], other: GenericMatrix[T]) -> None: ...

    def __len__(self: Self) -> int: ...
    def __iter__(self: Self) -> Iterator[T]: ...
    def __reversed__(self: Self) -> Iterator[T]: ...
    def __contains__(self: Self, value: Any) -> bool: ...
    def __copy__(self: Self) -> Self: ...
    def __deepcopy__(self: Self, memo: Optional[dict[int, Any]] = None) -> Self: ...


class OrderingMatrix(GenericMatrix[SupportsComparisonT]):
    if sys.version_info >= (3, 11):
        Self = typing.Self
    else:
        Self = TypeVar("Self", bound="OrderingMatrix")

    # Like with __eq__() and __ne__(), we're assuming that the contained type
    # returns boolean values in its comparison overloads. Again, common enough
    # that it should be safe.

    def __lt__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...
    def __gt__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...
    def __le__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...
    def __ge__(self: Self, other: GenericMatrix) -> "RealMatrix[bool]": ...


if sys.version_info >= (3, 10):
    from typing import ParamSpec

    P = ParamSpec("P")

    # Mypy thinks there's an error in this ParamSpec usage, but will still
    # infer everything correctly - don't know what's going on with that
    class CallableMatrix(GenericMatrix[Callable[P, T]]):  # type: ignore[misc]
        if sys.version_info >= (3, 11):
            Self = typing.Self
        else:
            Self = TypeVar("Self", bound="CallableMatrix")

        def __call__(self: Self, *args: P.args, **kwargs: P.kwargs) -> GenericMatrix[T]: ...

else:

    class CallableMatrix(GenericMatrix[Callable[..., T]]):
        Self = TypeVar("Self", bound="CallableMatrix")

        def __call__(self: Self, *args: Any, **kwargs: Any) -> GenericMatrix[T]: ...


class ComplexMatrix(GenericMatrix[ComplexT]):
    if sys.version_info >= (3, 11):
        Self = typing.Self
    else:
        Self = TypeVar("Self", bound="ComplexMatrix")

    @classmethod
    def identity(cls: type[Self], n: int) -> Self: ...

    def norm(self: Self) -> Real: ...
    def dot(self: Self, other: ComplexMatrix) -> Complex: ...

    def abs(self: Self) -> RealMatrix: ...
    def conjugate(self: Self) -> ComplexMatrix: ...

    def __add__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __sub__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __mul__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __truediv__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __pow__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __matmul__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...

    def __radd__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __rsub__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __rmul__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __rtruediv__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __rpow__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...
    def __rmatmul__(self: Self, other: GenericMatrix) -> ComplexMatrix: ...

    def __neg__(self: Self) -> ComplexMatrix: ...
    def __pos__(self: Self) -> ComplexMatrix: ...


class RealMatrix(ComplexMatrix[RealT], OrderingMatrix[RealT]):
    if sys.version_info >= (3, 11):
        Self = typing.Self
    else:
        Self = TypeVar("Self", bound="RealMatrix")

    def trunc(self: Self) -> RealMatrix[int]: ...
    def floor(self: Self) -> RealMatrix[int]: ...
    def ceil(self: Self) -> RealMatrix[int]: ...

    @typing.overload
    def round(self: Self) -> RealMatrix[int]: ...
    @typing.overload
    def round(self: Self, ndigits: SupportsIndex) -> RealMatrix: ...

    def abs(self: Self) -> RealMatrix: ...
    def conjugate(self: Self) -> RealMatrix: ...

    def __add__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __sub__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __mul__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __truediv__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __floordiv__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __mod__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __pow__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __matmul__(self: Self, other: GenericMatrix) -> RealMatrix: ...

    def __radd__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __rsub__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __rmul__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __rtruediv__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __rfloordiv__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __rmod__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __rpow__(self: Self, other: GenericMatrix) -> RealMatrix: ...
    def __rmatmul__(self: Self, other: GenericMatrix) -> RealMatrix: ...

    def __neg__(self: Self) -> RealMatrix: ...
    def __pos__(self: Self) -> RealMatrix: ...
