from collections.abc import Iterable, Iterator, MutableSequence
from typing import Any, Literal, Optional, SupportsIndex, TypeVar, overload

from .core.matrices import MatrixLike
from .core.rule import Rule
from .core.typeshed import (SupportsAbs, SupportsAdd, SupportsConjugate,
                            SupportsFloorDiv, SupportsGE, SupportsGT,
                            SupportsLE, SupportsLT, SupportsMod, SupportsMul,
                            SupportsNeg, SupportsPos, SupportsPow,
                            SupportsRAdd, SupportsRFloorDiv, SupportsRMod,
                            SupportsRMul, SupportsRPow, SupportsRSub,
                            SupportsRTrueDiv, SupportsSub, SupportsTrueDiv)
from .shapes import Shape, ShapeView

T  = TypeVar("T")
T1 = TypeVar("T1")
T2 = TypeVar("T2")

DTypeT_co = TypeVar("DTypeT_co", covariant=True)
NRowsT_co = TypeVar("NRowsT_co", covariant=True, bound=int)
NColsT_co = TypeVar("NColsT_co", covariant=True, bound=int)


FrozenMatrixT = TypeVar("FrozenMatrixT", bound=FrozenMatrix)

class FrozenMatrix(MatrixLike[DTypeT_co, NRowsT_co, NColsT_co]):

    __slots__: tuple[Literal["_array"], Literal["_shape"]]

    def __init__(self, data: Optional[Iterable[DTypeT_co]], nrows: Optional[NRowsT_co] = None, ncols: Optional[NColsT_co] = None) -> None: ...
    def __repr__(self) -> str: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> DTypeT_co: ...
    @overload
    def __getitem__(self, key: slice) -> FrozenMatrix[DTypeT_co, Literal[1], int]: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, SupportsIndex]) -> DTypeT_co: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, slice]) -> FrozenMatrix[DTypeT_co, Literal[1], int]: ...
    @overload
    def __getitem__(self, key: tuple[slice, SupportsIndex]) -> FrozenMatrix[DTypeT_co, int, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> FrozenMatrix[DTypeT_co, int, int]: ...
    def __iter__(self) -> Iterator[DTypeT_co]: ...
    def __reversed__(self) -> Iterator[DTypeT_co]: ...
    def __contains__(self, value: Any) -> bool: ...
    @overload
    def __add__(self: MatrixLike[SupportsAdd[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __add__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRAdd[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __sub__(self: MatrixLike[SupportsSub[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __sub__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRSub[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __mul__(self: MatrixLike[SupportsMul[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __mul__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRMul[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __truediv__(self: MatrixLike[SupportsTrueDiv[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __truediv__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRTrueDiv[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __floordiv__(self: MatrixLike[SupportsFloorDiv[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __floordiv__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRFloorDiv[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __mod__(self: MatrixLike[SupportsMod[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __mod__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRMod[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __pow__(self: MatrixLike[SupportsPow[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __pow__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRPow[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    def __and__(self, other: MatrixLike[Any, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def __or__(self, other: MatrixLike[Any, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def __xor__(self, other: MatrixLike[Any, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def __neg__(self: MatrixLike[SupportsNeg[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    def __pos__(self: MatrixLike[SupportsPos[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    def __abs__(self: MatrixLike[SupportsAbs[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    def __invert__(self) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...

    @classmethod
    def wrap(cls: type[FrozenMatrixT], array: MutableSequence[DTypeT_co], shape: Shape[NRowsT_co, NColsT_co]) -> FrozenMatrixT: ...

    @property
    def shape(self) -> ShapeView[NRowsT_co, NColsT_co]: ...

    def eq(self, other: MatrixLike[Any, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def ne(self, other: MatrixLike[Any, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def lt(self: MatrixLike[SupportsLT[T], NRowsT_co, NColsT_co], other: MatrixLike[T, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def lt(self: MatrixLike[SupportsGT[T], NRowsT_co, NColsT_co], other: MatrixLike[T, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def lt(self: MatrixLike[T, NRowsT_co, NColsT_co], other: MatrixLike[SupportsLT[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def lt(self: MatrixLike[T, NRowsT_co, NColsT_co], other: MatrixLike[SupportsGT[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def le(self: MatrixLike[SupportsLE[T], NRowsT_co, NColsT_co], other: MatrixLike[T, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def le(self: MatrixLike[SupportsGE[T], NRowsT_co, NColsT_co], other: MatrixLike[T, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def le(self: MatrixLike[T, NRowsT_co, NColsT_co], other: MatrixLike[SupportsLE[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def le(self: MatrixLike[T, NRowsT_co, NColsT_co], other: MatrixLike[SupportsGE[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def gt(self: MatrixLike[SupportsLT[T], NRowsT_co, NColsT_co], other: MatrixLike[T, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def gt(self: MatrixLike[SupportsGT[T], NRowsT_co, NColsT_co], other: MatrixLike[T, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def gt(self: MatrixLike[T, NRowsT_co, NColsT_co], other: MatrixLike[SupportsLT[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def gt(self: MatrixLike[T, NRowsT_co, NColsT_co], other: MatrixLike[SupportsGT[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def ge(self: MatrixLike[SupportsLE[T], NRowsT_co, NColsT_co], other: MatrixLike[T, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def ge(self: MatrixLike[SupportsGE[T], NRowsT_co, NColsT_co], other: MatrixLike[T, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def ge(self: MatrixLike[T, NRowsT_co, NColsT_co], other: MatrixLike[SupportsLE[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    @overload
    def ge(self: MatrixLike[T, NRowsT_co, NColsT_co], other: MatrixLike[SupportsGE[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def conjugate(self: MatrixLike[SupportsConjugate[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    @overload
    def slices(self, *, by: Literal[Rule.ROW]) -> Iterator[FrozenMatrix[DTypeT_co, Literal[1], NColsT_co]]: ...
    @overload
    def slices(self, *, by: Literal[Rule.COL]) -> Iterator[FrozenMatrix[DTypeT_co, NRowsT_co, Literal[1]]]: ...
    @overload
    def slices(self, *, by: Rule) -> Iterator[FrozenMatrix[DTypeT_co, int, int]]: ...
    @overload
    def slices(self) -> Iterator[FrozenMatrix[DTypeT_co, Literal[1], NColsT_co]]: ...
