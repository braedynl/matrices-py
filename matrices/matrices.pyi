import sys
from collections.abc import Callable, Collection, Iterable, Iterator, Sequence
from enum import Enum
from typing import (Any, Literal, Optional, SupportsIndex, TypeVar, final,
                    overload)

T = TypeVar("T")
S = TypeVar("S")


@final
class Rule(Enum):

    ROW: int
    COL: int

    @property
    def inverse(self) -> Rule: ...
    @property
    def true_name(self) -> Literal["row", "column"]: ...

    def subshape(self, shape: Shape) -> Shape: ...
    def serialize(self, index: int, shape: Shape) -> tuple[int, int, int]: ...
    def range(self, index: int, shape: Shape) -> range: ...
    def slice(self, index: int, shape: Shape) -> slice: ...

    def __index__(self) -> int: ...
    def __invert__(self) -> Rule: ...


ROW: Literal[Rule.ROW]
COL: Literal[Rule.COL]


@final
class Shape(Collection[int]):

    @property
    def data(self) -> list[int]: ...
    @property
    def nrows(self) -> int: ...
    @nrows.setter
    def nrows(self, value: int) -> None: ...
    @property
    def ncols(self) -> int: ...
    @ncols.setter
    def ncols(self, value: int) -> None: ...
    @property
    def size(self) -> int: ...

    def copy(self) -> Shape: ...
    def reverse(self) -> Shape: ...
    def match(self, other: Shape) -> Shape: ...
    def resolve_index(self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def resolve_slice(self, key: slice, *, by: Rule = Rule.ROW) -> range: ...

    def __init__(self, nrows: int = 0, ncols: int = 0) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __getitem__(self, key: SupportsIndex) -> int: ...
    def __setitem__(self, key: SupportsIndex, value: int) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __copy__(self) -> Shape: ...
    def __deepcopy__(self, memo: Optional[dict[int, Any]] = None) -> Shape: ...


GenericMatrixT = TypeVar("GenericMatrixT", bound=GenericMatrix)

class GenericMatrix(Sequence[T]):

    @classmethod
    def wrap(cls: type[GenericMatrixT], data: list[T], shape: Shape) -> GenericMatrixT: ...
    @classmethod
    def fill(cls: type[GenericMatrixT], value: T, nrows: int, ncols: int) -> GenericMatrixT: ...
    @classmethod
    def refer(cls: type[GenericMatrixT], other: GenericMatrix[T]) -> GenericMatrixT: ...
    @classmethod
    def infer(cls: type[GenericMatrixT], other: Iterable[Iterable[T]]) -> GenericMatrixT: ...

    @property
    def data(self: GenericMatrixT) -> list[T]: ...
    @property
    def shape(self: GenericMatrixT) -> Shape: ...
    @property
    def size(self: GenericMatrixT) -> int: ...
    @property
    def nrows(self: GenericMatrixT) -> int: ...
    @property
    def ncols(self: GenericMatrixT) -> int: ...

    def index(self: GenericMatrixT, value: T, start: int = 0, stop: Optional[int] = None) -> int: ...
    def count(self: GenericMatrixT, value: T) -> int: ...
    def reshape(self: GenericMatrixT, nrows: int, ncols: int) -> GenericMatrixT: ...
    def slices(self: GenericMatrixT, *, by: Rule = Rule.ROW) -> Iterator[GenericMatrixT]: ...
    def mask(self: GenericMatrixT, selector: GenericMatrix, null: T) -> GenericMatrixT: ...
    def replace(self: GenericMatrixT, old: T, new: T, *, times: Optional[int] = None) -> GenericMatrixT: ...
    def reverse(self: GenericMatrixT) -> GenericMatrixT: ...
    def swap(self: GenericMatrixT, key1: SupportsIndex, key2: SupportsIndex, *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def flip(self: GenericMatrixT, *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def flatten(self: GenericMatrixT, *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def transpose(self: GenericMatrixT) -> GenericMatrixT: ...
    def stack(self: GenericMatrixT, other: GenericMatrix[T], *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def pull(self: GenericMatrixT, key: SupportsIndex = -1, *, by: Rule = Rule.ROW) -> GenericMatrixT: ...
    def copy(self: GenericMatrixT, *, deep: bool = False) -> GenericMatrixT: ...

    def __init__(self: GenericMatrixT, values: Iterable[T], nrows: int, ncols: int) -> None: ...
    def __repr__(self: GenericMatrixT) -> str: ...
    def __str__(self: GenericMatrixT) -> str: ...

    # By returning a RealMatrix, we're expecting the elements to return
    # booleans in their implementation of __eq__() and __ne__(). This is
    # conventional, and lightly enforced by built-in object. Returning other
    # things is rare enough to the point where it should be safe.

    # The logical operators &, |, ^, and ~, guarantee boolean results due to
    # their functional implementation found in utilities.py.

    def __eq__(self: GenericMatrixT, other: GenericMatrix): ...  # type: ignore[override]
    def __ne__(self: GenericMatrixT, other: GenericMatrix): ...  # type: ignore[override]

    def __and__(self: GenericMatrixT, other: GenericMatrix): ...
    def __xor__(self: GenericMatrixT, other: GenericMatrix): ...
    def __or__(self: GenericMatrixT, other: GenericMatrix): ...

    def __rand__(self: GenericMatrixT, other: GenericMatrix): ...
    def __rxor__(self: GenericMatrixT, other: GenericMatrix): ...
    def __ror__(self: GenericMatrixT, other: GenericMatrix): ...

    def __invert__(self: GenericMatrixT): ...

    @overload
    def __getitem__(self: GenericMatrixT, key: SupportsIndex) -> T: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: slice) -> GenericMatrixT: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: tuple[SupportsIndex, SupportsIndex]) -> T: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: tuple[SupportsIndex, slice]) -> GenericMatrixT: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: tuple[slice, SupportsIndex]) -> GenericMatrixT: ...
    @overload
    def __getitem__(self: GenericMatrixT, key: tuple[slice, slice]) -> GenericMatrixT: ...

    @overload
    def __setitem__(self: GenericMatrixT, key: SupportsIndex, other: T) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: slice, other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: tuple[SupportsIndex, SupportsIndex], other: T) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: tuple[SupportsIndex, slice], other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: tuple[slice, SupportsIndex], other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: GenericMatrixT, key: tuple[slice, slice], other: GenericMatrix[T]) -> None: ...

    def __len__(self: GenericMatrixT) -> int: ...
    def __iter__(self: GenericMatrixT) -> Iterator[T]: ...
    def __reversed__(self: GenericMatrixT) -> Iterator[T]: ...
    def __contains__(self: GenericMatrixT, value: Any) -> bool: ...
    def __copy__(self: GenericMatrixT) -> GenericMatrixT: ...
    def __deepcopy__(self: GenericMatrixT, memo: Optional[dict[int, Any]] = None) -> GenericMatrixT: ...


CallableMatrixT = TypeVar("CallableMatrixT", bound=CallableMatrix)

if sys.version_info >= (3, 10):
    from typing import ParamSpec

    P = ParamSpec("P")

    # Mypy thinks there's an error in this ParamSpec usage, but will still
    # infer everything correctly - don't know what's going on with that
    class CallableMatrix(GenericMatrix[Callable[P, T]]):  # type: ignore[misc]

        def __call__(self: CallableMatrixT, *args: P.args, **kwargs: P.kwargs) -> GenericMatrix[T]: ...

else:

    class CallableMatrix(GenericMatrix[Callable[..., T]]):

        def __call__(self: CallableMatrixT, *args: Any, **kwargs: Any) -> GenericMatrix[T]: ...
