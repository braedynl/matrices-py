from collections.abc import Collection, Iterable, Sequence
from enum import Enum
from typing import (Any, Iterator, Literal, Optional, SupportsIndex, TypeVar,
                    final, overload)

from .protocols import MatrixLike, ShapeLike

T = TypeVar("T")
T_co = TypeVar("T_co", covariant=True)

Self = TypeVar("Self")

Complex = complex
Float = float
Int = int


@final
class Rule(Enum):

    ROW: int
    COL: int

    def __index__(self: Self) -> int: ...
    def __invert__(self: Self) -> Rule: ...

    @property
    def true_name(self: Self) -> Literal["row", "column"]: ...

    def subshape(self: Self, shape: Shape) -> Shape: ...
    def serialize(self: Self, index: int, shape: Shape) -> tuple[int, int, int]: ...
    def range(self: Self, index: int, shape: Shape) -> range: ...
    def slice(self: Self, index: int, shape: Shape) -> slice: ...


ROW: Literal[Rule.ROW]
COL: Literal[Rule.COL]


@final
class Shape(ShapeLike, Collection[int]):

    __slots__: tuple[Literal["data"]]

    def __init__(self: Self, nrows: int = 0, ncols: int = 0) -> None: ...
    def __repr__(self: Self) -> str: ...
    def __str__(self: Self) -> str: ...
    def __eq__(self: Self, other: Any) -> bool: ...
    def __ne__(self: Self, other: Any) -> bool: ...
    def __len__(self: Self) -> Literal[2]: ...
    def __getitem__(self: Self, key: SupportsIndex) -> int: ...
    def __setitem__(self: Self, key: SupportsIndex, value: int) -> None: ...
    def __iter__(self: Self) -> Iterator[int]: ...
    def __reversed__(self: Self) -> Iterator[int]: ...
    def __contains__(self: Self, value: Any) -> bool: ...
    def __deepcopy__(self: Self, memo: Optional[dict[int, Any]] = None) -> Shape: ...
    def __copy__(self: Self) -> Shape: ...

    @property
    def nrows(self: Self) -> int: ...
    @nrows.setter
    def nrows(self: Self, value: int) -> None: ...
    @property
    def ncols(self: Self) -> int: ...
    @ncols.setter
    def ncols(self: Self, value: int) -> None: ...
    @property
    def size(self: Self) -> int: ...

    def copy(self: Self) -> Shape: ...
    def reverse(self: Self) -> Shape: ...
    def resolve_index(self: Self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def resolve_slice(self: Self, key: slice, *, by: Rule = Rule.ROW) -> range: ...


class GenericMatrix(MatrixLike[T], Sequence[T]):

    __slots__: tuple[Literal["data"], Literal["shape"]]

    def __init__(self: Self, values: Iterable[T], nrows: int, ncols: int) -> None: ...
    def __repr__(self: Self) -> str: ...
    def __str__(self: Self) -> str: ...
    @overload
    def __getitem__(self: Self, key: SupportsIndex) -> T: ...
    @overload
    def __getitem__(self: Self, key: slice) -> Self: ...
    @overload
    def __getitem__(self: Self, key: tuple[SupportsIndex, SupportsIndex]) -> T: ...
    @overload
    def __getitem__(self: Self, key: tuple[SupportsIndex, slice]) -> Self: ...
    @overload
    def __getitem__(self: Self, key: tuple[slice, SupportsIndex]) -> Self: ...
    @overload
    def __getitem__(self: Self, key: tuple[slice, slice]) -> Self: ...
    @overload
    def __setitem__(self: Self, key: SupportsIndex, value: T) -> None: ...
    @overload
    def __setitem__(self: Self, key: slice, other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: Self, key: tuple[SupportsIndex, SupportsIndex], value: T) -> None: ...
    @overload
    def __setitem__(self: Self, key: tuple[SupportsIndex, slice], other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: Self, key: tuple[slice, SupportsIndex], other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: Self, key: tuple[slice, slice], other: GenericMatrix[T]) -> None: ...
    def __len__(self: Self) -> int: ...
    def __iter__(self: Self) -> Iterator[T]: ...
    def __reversed__(self: Self) -> Iterator[T]: ...
    def __contains__(self: Self, value: Any) -> bool: ...
    def __deepcopy__(self: Self, memo: Optional[dict[int, Any]] = None) -> Self: ...
    def __copy__(self: Self) -> Self: ...

    # def __eq__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...  # type: ignore[override]
    # def __ne__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...  # type: ignore[override]

    # def __and__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...
    # def __or__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...
    # def __xor__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...

    # def __rand__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...
    # def __ror__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...
    # def __rxor__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...

    # def __invert__(self: Self) -> IntegralMatrix[bool]: ...

    @classmethod
    def wrap(cls: type[Self], data: list[T], shape: Shape) -> Self: ...
    @classmethod
    def fill(cls: type[Self], value: T, nrows: int, ncols: int) -> Self: ...
    @classmethod
    def refer(cls: type[Self], other: GenericMatrix[T]) -> Self: ...
    @classmethod
    def infer(cls: type[Self], other: Iterable[Iterable[T]]) -> Self: ...

    @property
    def shape(self: Self) -> Shape: ...
    @property
    def nrows(self: Self) -> int: ...
    @property
    def ncols(self: Self) -> int: ...
    @property
    def size(self: Self) -> int: ...

    def index(self: Self, value: T, start: int = 0, stop: Optional[int] = None) -> int: ...
    def count(self: Self, value: T) -> int: ...
    def reshape(self: Self, nrows: int, ncols: int) -> Self: ...
    def slices(self: Self, *, by: Rule = Rule.ROW) -> Iterator[Self]: ...
    def mask(self: Self, selector: GenericMatrix[Any], null: T) -> Self: ...
    def replace(self: Self, old: T, new: T, *, times: Optional[int] = None) -> Self: ...
    def reverse(self: Self) -> Self: ...
    def swap(self: Self, key1: SupportsIndex, key2: SupportsIndex, *, by: Rule = Rule.ROW) -> Self: ...
    def flip(self: Self, *, by: Rule = Rule.ROW) -> Self: ...
    def flatten(self: Self, *, by: Rule = Rule.ROW) -> Self: ...
    def transpose(self: Self) -> Self: ...
    def stack(self: Self, other: GenericMatrix[T], *, by: Rule = Rule.ROW) -> Self: ...
    def pull(self: Self, key: SupportsIndex = -1, *, by: Rule = Rule.ROW) -> Self: ...
    def copy(self: Self, *, deep: bool = False) -> Self: ...
