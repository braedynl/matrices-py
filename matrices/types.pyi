import sys
from abc import abstractmethod
from collections.abc import Collection, Iterable, Sequence
from enum import Enum
from typing import (Any, Iterator, Literal, Optional, Protocol, SupportsIndex,
                    TypeVar, Union, final, overload, runtime_checkable)

T = TypeVar("T")
T_co = TypeVar("T_co", covariant=True)

Self = TypeVar("Self")


@final
class Rule(Enum):

    ROW: int
    COL: int

    def __index__(self: Self) -> int: ...
    def __invert__(self: Self) -> Rule: ...

    @property
    def true_name(self: Self) -> Literal["row", "column"]: ...

    def subshape(self: Self, shape: Shape) -> Shape: ...
    def serialize(self: Self, index: int, shape: Shape) -> tuple[int, int, int]: ...
    def range(self: Self, index: int, shape: Shape) -> range: ...
    def slice(self: Self, index: int, shape: Shape) -> slice: ...


ROW: Literal[Rule.ROW]
COL: Literal[Rule.COL]


@final
class Shape(Collection[int]):

    __slots__: tuple[Literal["data"]]

    def __init__(self: Self, nrows: int = 0, ncols: int = 0) -> None: ...
    def __repr__(self: Self) -> str: ...
    def __str__(self: Self) -> str: ...
    def __eq__(self: Self, other: Any) -> bool: ...
    def __ne__(self: Self, other: Any) -> bool: ...
    def __getitem__(self: Self, key: SupportsIndex) -> int: ...
    def __setitem__(self: Self, key: SupportsIndex, value: int) -> None: ...
    def __len__(self: Self) -> Literal[2]: ...
    def __iter__(self: Self) -> Iterator[int]: ...
    def __contains__(self: Self, value: Any) -> bool: ...
    def __deepcopy__(self: Self, memo: Optional[dict[int, Any]] = None) -> Self: ...
    def __copy__(self: Self) -> Self: ...

    @property
    def nrows(self: Self) -> int: ...
    @nrows.setter
    def nrows(self: Self, value: int) -> None: ...
    @property
    def ncols(self: Self) -> int: ...
    @ncols.setter
    def ncols(self: Self, value: int) -> None: ...
    @property
    def size(self: Self) -> int: ...

    def copy(self: Self) -> Self: ...
    def reverse(self: Self) -> Self: ...
    def resolve_index(self: Self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def resolve_slice(self: Self, key: slice, *, by: Rule = Rule.ROW) -> range: ...


class GenericMatrix(Sequence[T]):

    __slots__: tuple[Literal["data"], Literal["shape"]]

    def __init__(self: Self, values: Iterable[T], nrows: int, ncols: int) -> None: ...
    def __repr__(self: Self) -> str: ...
    def __str__(self: Self) -> str: ...
    @overload
    def __getitem__(self: Self, key: SupportsIndex) -> T: ...
    @overload
    def __getitem__(self: Self, key: slice) -> Self: ...
    @overload
    def __getitem__(self: Self, key: tuple[SupportsIndex, SupportsIndex]) -> T: ...
    @overload
    def __getitem__(self: Self, key: tuple[SupportsIndex, slice]) -> Self: ...
    @overload
    def __getitem__(self: Self, key: tuple[slice, SupportsIndex]) -> Self: ...
    @overload
    def __getitem__(self: Self, key: tuple[slice, slice]) -> Self: ...
    @overload
    def __setitem__(self: Self, key: SupportsIndex, value: T) -> None: ...
    @overload
    def __setitem__(self: Self, key: slice, other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: Self, key: tuple[SupportsIndex, SupportsIndex], value: T) -> None: ...
    @overload
    def __setitem__(self: Self, key: tuple[SupportsIndex, slice], other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: Self, key: tuple[slice, SupportsIndex], other: GenericMatrix[T]) -> None: ...
    @overload
    def __setitem__(self: Self, key: tuple[slice, slice], other: GenericMatrix[T]) -> None: ...
    def __len__(self: Self) -> int: ...
    def __iter__(self: Self) -> Iterator[T]: ...
    def __reversed__(self: Self) -> Iterator[T]: ...
    def __contains__(self: Self, value: Any) -> bool: ...
    def __deepcopy__(self: Self, memo: Optional[dict[int, Any]] = None) -> Self: ...
    def __copy__(self: Self) -> Self: ...

    # def __eq__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...  # type: ignore[override]
    # def __ne__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...  # type: ignore[override]

    # def __and__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...
    # def __or__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...
    # def __xor__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...

    # def __rand__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...
    # def __ror__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...
    # def __rxor__(self: Self, other: Union[GenericMatrix[Any], Any]) -> IntegralMatrix[bool]: ...

    # def __invert__(self: Self) -> IntegralMatrix[bool]: ...

    @classmethod
    def wrap(cls: type[Self], data: list[T], shape: Shape) -> Self: ...
    @classmethod
    def fill(cls: type[Self], value: T, nrows: int, ncols: int) -> Self: ...
    @classmethod
    def refer(cls: type[Self], other: GenericMatrix[T]) -> Self: ...
    @classmethod
    def infer(cls: type[Self], other: Iterable[Iterable[T]]) -> Self: ...

    @property
    def nrows(self: Self) -> int: ...
    @property
    def ncols(self: Self) -> int: ...
    @property
    def size(self: Self) -> int: ...

    def index(self: Self, value: T, start: int = 0, stop: Optional[int] = None) -> int: ...
    def count(self: Self, value: T) -> int: ...
    def reshape(self: Self, nrows: int, ncols: int) -> Self: ...
    def slices(self: Self, *, by: Rule = Rule.ROW) -> Iterator[Self]: ...
    def mask(self: Self, selector: GenericMatrix[Any], null: T) -> Self: ...
    def replace(self: Self, old: T, new: T, *, times: Optional[int] = None) -> Self: ...
    def reverse(self: Self) -> Self: ...
    def swap(self: Self, key1: SupportsIndex, key2: SupportsIndex, *, by: Rule = Rule.ROW) -> Self: ...
    def flip(self: Self, *, by: Rule = Rule.ROW) -> Self: ...
    def flatten(self: Self, *, by: Rule = Rule.ROW) -> Self: ...
    def transpose(self: Self) -> Self: ...
    def stack(self: Self, other: GenericMatrix[T], *, by: Rule = Rule.ROW) -> Self: ...
    def pull(self: Self, key: SupportsIndex = -1, *, by: Rule = Rule.ROW) -> Self: ...
    def copy(self: Self, *, deep: bool = False) -> Self: ...


@runtime_checkable
class ComplexLike(Protocol):

    # This method is only defined for version 3.11 or higher, as the built-in
    # complex type does not define it in prior versions.

    if sys.version_info >= (3, 11):
        @abstractmethod
        def __complex__(self: Self) -> complex: ...

    # The binary methods below should always produce a new complex-like when
    # the operand is a complex-like - do not return other types.

    @abstractmethod
    def __add__(self: Self, other: Any) -> ComplexLike: ...
    def __sub__(self: Self, other: Any) -> ComplexLike: ...
    @abstractmethod
    def __mul__(self: Self, other: Any) -> ComplexLike: ...
    @abstractmethod
    def __truediv__(self: Self, other: Any) -> ComplexLike: ...
    @abstractmethod
    def __pow__(self: Self, other: Any) -> ComplexLike: ...

    @abstractmethod
    def __radd__(self: Self, other: Any) -> ComplexLike: ...
    def __rsub__(self: Self, other: Any) -> ComplexLike: ...
    @abstractmethod
    def __rmul__(self: Self, other: Any) -> ComplexLike: ...
    @abstractmethod
    def __rtruediv__(self: Self, other: Any) -> ComplexLike: ...
    @abstractmethod
    def __rpow__(self: Self, other: Any) -> ComplexLike: ...

    @abstractmethod
    def __neg__(self: Self) -> ComplexLike: ...
    @abstractmethod
    def __pos__(self: Self) -> ComplexLike: ...
    @abstractmethod
    def __abs__(self: Self) -> RealLike: ...

    @abstractmethod
    def conjugate(self: Self) -> ComplexLike: ...


@runtime_checkable
class RealLike(ComplexLike, Protocol):

    # You should be able to compare with any real-like. Complex-likes are
    # incomparable.

    @abstractmethod
    def __lt__(self: Self, other: Any) -> bool: ...
    @abstractmethod
    def __le__(self: Self, other: Any) -> bool: ...

    if sys.version_info >= (3, 11):
        def __complex__(self: Self) -> complex: ...
    @abstractmethod
    def __float__(self: Self) -> float: ...

    @abstractmethod
    @overload
    def __round__(self: Self) -> int: ...
    @abstractmethod
    @overload
    def __round__(self: Self, ndigits: int) -> RealLike: ...
    @abstractmethod
    def __trunc__(self: Self) -> int: ...
    @abstractmethod
    def __floor__(self: Self) -> int: ...
    @abstractmethod
    def __ceil__(self: Self) -> int: ...

    # These methods should return real-likes when possible - when not, provide
    # an overload that returns a complex-like.

    @abstractmethod
    def __add__(self: Self, other: Any) -> RealLike: ...
    def __sub__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __mul__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __truediv__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __pow__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __floordiv__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __mod__(self: Self, other: Any) -> RealLike: ...

    @abstractmethod
    def __radd__(self: Self, other: Any) -> RealLike: ...
    def __rsub__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __rmul__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __rtruediv__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __rpow__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __rfloordiv__(self: Self, other: Any) -> RealLike: ...
    @abstractmethod
    def __rmod__(self: Self, other: Any) -> RealLike: ...

    @abstractmethod
    def __neg__(self: Self) -> RealLike: ...
    @abstractmethod
    def __pos__(self: Self) -> RealLike: ...
    @abstractmethod
    def __abs__(self: Self) -> RealLike: ...

    def conjugate(self: Self) -> RealLike: ...


@runtime_checkable
class IntegralLike(RealLike, Protocol):

    def __float__(self: Self) -> float: ...
    @abstractmethod
    def __int__(self: Self) -> int: ...
    def __index__(self: Self) -> int: ...

    # These methods should return integral-likes when possible - when not,
    # provide an overload that returns a complex or real-like (however specific
    # you can be).

    # __truediv__() and __rtruediv__() are omitted, since you're likely to
    # return a real-like more than anything. Implementors are still free to
    # return integral-likes when possible, however.

    @abstractmethod
    def __add__(self: Self, other: Any) -> IntegralLike: ...
    def __sub__(self: Self, other: Any) -> IntegralLike: ...
    @abstractmethod
    def __mul__(self: Self, other: Any) -> IntegralLike: ...
    @abstractmethod
    def __pow__(self: Self, other: Any) -> IntegralLike: ...
    @abstractmethod
    def __floordiv__(self: Self, other: Any) -> IntegralLike: ...
    @abstractmethod
    def __mod__(self: Self, other: Any) -> IntegralLike: ...

    @abstractmethod
    def __radd__(self: Self, other: Any) -> IntegralLike: ...
    def __rsub__(self: Self, other: Any) -> IntegralLike: ...
    @abstractmethod
    def __rmul__(self: Self, other: Any) -> IntegralLike: ...
    @abstractmethod
    def __rpow__(self: Self, other: Any) -> IntegralLike: ...
    @abstractmethod
    def __rfloordiv__(self: Self, other: Any) -> IntegralLike: ...
    @abstractmethod
    def __rmod__(self: Self, other: Any) -> IntegralLike: ...

    @abstractmethod
    def __neg__(self: Self) -> IntegralLike: ...
    @abstractmethod
    def __pos__(self: Self) -> IntegralLike: ...
    @abstractmethod
    def __abs__(self: Self) -> IntegralLike: ...

    def conjugate(self: Self) -> IntegralLike: ...


ComplexLikeT  = TypeVar("ComplexLikeT",  bound=ComplexLike)
RealLikeT     = TypeVar("RealLikeT",     bound=RealLike)
IntegralLikeT = TypeVar("IntegralLikeT", bound=IntegralLike)


# class ComplexMatrixLike(Protocol[T_co]):

#     def __add__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __sub__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __mul__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __truediv__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __pow__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __matmul__(self: Self, other: Any) -> ComplexMatrixLike: ...

#     def __radd__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __rsub__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __rmul__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __rtruediv__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __rpow__(self: Self, other: Any) -> ComplexMatrixLike: ...
#     def __rmatmul__(self: Self, other: Any) -> ComplexMatrixLike: ...

#     def __neg__(self: Self) -> ComplexMatrixLike: ...
#     def __pos__(self: Self) -> ComplexMatrixLike: ...

#     @property
#     def bounds(self: Self) -> tuple[type, ...]: ...

#     def abs(self: Self) -> ComplexMatrixLike: ...
#     def conjugate(self: Self) -> ComplexMatrixLike: ...
#     def complex(self: Self) -> ComplexMatrixLike: ...


# @final
# class IntegralMatrix(GenericMatrix[IntegralT]):

#     __slots__: tuple[()]


# @final
# class RealMatrix(GenericMatrix[RealT]):

#     __slots__: tuple[()]


# @final
# class ComplexMatrix(GenericMatrix[ComplexT]):

#     __slots__: tuple[()]

#     @overload
#     def __add__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __add__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...
#     @overload
#     def __sub__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __sub__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...
#     @overload
#     def __mul__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __mul__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...
#     @overload
#     def __truediv__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __truediv__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...
#     @overload
#     def __pow__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __pow__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...

#     @overload
#     def __radd__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __radd__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...
#     @overload
#     def __rsub__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __rsub__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...
#     @overload
#     def __rmul__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __rmul__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...
#     @overload
#     def __rtruediv__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __rtruediv__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...
#     @overload
#     def __rpow__(self: ComplexMatrix[complex], other: Union[BuiltinComplexMatrix, BuiltinComplex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __rpow__(self: Self, other: Union[AnyComplexMatrix, AnyComplex]) -> ComplexMatrix[Any]: ...

#     @overload
#     def __neg__(self: ComplexMatrix[complex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __neg__(self: Self) -> ComplexMatrix[Any]: ...
#     @overload
#     def __pos__(self: ComplexMatrix[complex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def __pos__(self: Self) -> ComplexMatrix[Any]: ...

#     @overload
#     def abs(self: ComplexMatrix[complex]) -> RealMatrix[float]: ...
#     @overload
#     def abs(self: Self) -> RealMatrix[Any]: ...
#     @overload
#     def conjugate(self: ComplexMatrix[complex]) -> ComplexMatrix[complex]: ...
#     @overload
#     def conjugate(self: Self) -> ComplexMatrix[Any]: ...
