from collections.abc import Iterator
from typing import (Any, Literal, Optional, SupportsIndex, TypeVar, final,
                    overload)

from .abstract import ShapeLike
from .rule import Rule

__all__ = ["Shape", "ShapeView"]


NRows = TypeVar("NRows", bound=int)
NCols = TypeVar("NCols", bound=int)

@final
class Shape(ShapeLike[NRows, NCols]):

    __slots__: tuple[Literal["_data"]]

    def __init__(self, nrows: NRows, ncols: NCols) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    @overload
    def __getitem__(self, key: Literal[0]) -> NRows: ...
    @overload
    def __getitem__(self, key: Literal[1]) -> NCols: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> NRows | NCols: ...
    @overload
    def __setitem__(self, key: Literal[0], value: NRows) -> None: ...
    @overload
    def __setitem__(self, key: Literal[1], value: NCols) -> None: ...
    @overload
    def __setitem__(self, key: SupportsIndex, value: NRows | NCols) -> None: ...
    def __iter__(self) -> Iterator[NRows | NCols]: ...
    def __reversed__(self) -> Iterator[NRows | NCols]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __deepcopy__(self, memo: Optional[dict[int, Any]] = None) -> Shape[NRows, NCols]: ...
    def __copy__(self) -> Shape[NRows, NCols]: ...

    @property
    def nrows(self) -> NRows: ...
    @nrows.setter
    def nrows(self, value: NRows) -> None: ...
    @property
    def ncols(self) -> NCols: ...
    @ncols.setter
    def ncols(self, value: NCols) -> None: ...

    def reverse(self) -> Shape[NCols, NRows]: ...
    def copy(self) -> Shape[NRows, NCols]: ...
    @overload
    def subshape(self, *, by: Literal[Rule.ROW]) -> Shape[Literal[1], NCols]: ...  # type: ignore[misc]
    @overload
    def subshape(self, *, by: Literal[Rule.COL]) -> Shape[NRows, Literal[1]]: ...  # type: ignore[misc]
    @overload
    def subshape(self, *, by: Rule) -> Shape[int, int]: ...
    @overload
    def subshape(self) -> Shape[Literal[1], NCols]: ...
    def resolve_index(self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def resolve_slice(self, key: slice, *, by: Rule = Rule.ROW) -> range: ...
    def sequence(self, index: int, *, by: Rule = Rule.ROW) -> tuple[int, int, int]: ...
    def range(self, index: int, *, by: Rule = Rule.ROW) -> range: ...
    def slice(self, index: int, *, by: Rule = Rule.ROW) -> slice: ...


NRows_co = TypeVar("NRows_co", bound=int, covariant=True)
NCols_co = TypeVar("NCols_co", bound=int, covariant=True)

@final
class ShapeView(ShapeLike[NRows_co, NCols_co]):

    __slots__: tuple[Literal["_target"]]

    def __init__(self, target: ShapeLike[NRows_co, NCols_co]) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    @overload
    def __getitem__(self, key: Literal[0]) -> NRows_co: ...
    @overload
    def __getitem__(self, key: Literal[1]) -> NCols_co: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> NRows_co | NCols_co: ...
    def __iter__(self) -> Iterator[NRows_co | NCols_co]: ...
    def __reversed__(self) -> Iterator[NRows_co | NCols_co]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __deepcopy__(self, memo: Optional[dict[int, Any]] = None) -> ShapeView[NRows_co, NCols_co]: ...
    def __copy__(self) -> ShapeView[NRows_co, NCols_co]: ...
