from collections.abc import Iterable, Iterator, MutableSequence
from typing import Any, Literal, Optional, SupportsIndex, TypeVar, overload

from .abstract import MatrixLike
from .shapes import Shape, ShapeView
from .typeshed import (SupportsAbs, SupportsAdd, SupportsAnd,
                       SupportsConjugate, SupportsDivMod, SupportsDotProduct,
                       SupportsFloorDiv, SupportsInvert, SupportsLShift,
                       SupportsMod, SupportsMonomorphicAdd, SupportsMul,
                       SupportsNeg, SupportsOr, SupportsPos, SupportsPow,
                       SupportsRAdd, SupportsRAnd, SupportsRDivMod,
                       SupportsRDotProduct, SupportsRFloorDiv, SupportsRLShift,
                       SupportsRMod, SupportsRMul, SupportsROr, SupportsRPow,
                       SupportsRRShift, SupportsRShift, SupportsRSub,
                       SupportsRTrueDiv, SupportsRXor, SupportsSub,
                       SupportsTrueDiv, SupportsXor)
from .utilities import Rule

T = TypeVar("T")

T1 = TypeVar("T1")
T2 = TypeVar("T2")

DTypeT = TypeVar("DTypeT")
NRowsT = TypeVar("NRowsT", bound=int)
NColsT = TypeVar("NColsT", bound=int)

DTypeT_co = TypeVar("DTypeT_co", covariant=True)
NRowsT_co = TypeVar("NRowsT_co", covariant=True, bound=int)
NColsT_co = TypeVar("NColsT_co", covariant=True, bound=int)

SupportsMonomorphicAddT = TypeVar("SupportsMonomorphicAddT", bound=SupportsMonomorphicAdd)
InnerT = TypeVar("InnerT", bound=int)


FrozenMatrixT = TypeVar("FrozenMatrixT", bound=FrozenMatrix)

class FrozenMatrix(MatrixLike[DTypeT_co, NRowsT_co, NColsT_co]):

    __slots__: tuple[Literal["_array"], Literal["_shape"]]

    def __init__(self, data: Optional[Iterable[DTypeT_co]], nrows: Optional[NRowsT_co] = None, ncols: Optional[NColsT_co] = None) -> None: ...
    def __repr__(self) -> str: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> DTypeT_co: ...
    @overload
    def __getitem__(self, key: slice) -> FrozenMatrix[DTypeT_co, Literal[1], int]: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, SupportsIndex]) -> DTypeT_co: ...
    @overload
    def __getitem__(self, key: tuple[SupportsIndex, slice]) -> FrozenMatrix[DTypeT_co, Literal[1], int]: ...
    @overload
    def __getitem__(self, key: tuple[slice, SupportsIndex]) -> FrozenMatrix[DTypeT_co, int, Literal[1]]: ...
    @overload
    def __getitem__(self, key: tuple[slice, slice]) -> FrozenMatrix[DTypeT_co, int, int]: ...
    def __iter__(self) -> Iterator[DTypeT_co]: ...
    def __reversed__(self) -> Iterator[DTypeT_co]: ...
    def __contains__(self, value: Any) -> bool: ...
    @overload
    def __add__(self: MatrixLike[SupportsAdd[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __add__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRAdd[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __sub__(self: MatrixLike[SupportsSub[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __sub__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRSub[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __mul__(self: MatrixLike[SupportsMul[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __mul__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRMul[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __truediv__(self: MatrixLike[SupportsTrueDiv[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __truediv__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRTrueDiv[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __floordiv__(self: MatrixLike[SupportsFloorDiv[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __floordiv__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRFloorDiv[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __mod__(self: MatrixLike[SupportsMod[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __mod__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRMod[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __divmod__(self: MatrixLike[SupportsDivMod[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __divmod__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRDivMod[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __pow__(self: MatrixLike[SupportsPow[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __pow__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRPow[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __lshift__(self: MatrixLike[SupportsLShift[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __lshift__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRLShift[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __rshift__(self: MatrixLike[SupportsRShift[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __rshift__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRRShift[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __and__(self: MatrixLike[SupportsAnd[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __and__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRAnd[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __xor__(self: MatrixLike[SupportsXor[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __xor__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsRXor[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __or__(self: MatrixLike[SupportsOr[T1, T2], NRowsT_co, NColsT_co], other: MatrixLike[T1, NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    @overload
    def __or__(self: MatrixLike[T1, NRowsT_co, NColsT_co], other: MatrixLike[SupportsROr[T1, T2], NRowsT_co, NColsT_co]) -> FrozenMatrix[T2, NRowsT_co, NColsT_co]: ...
    def __neg__(self: MatrixLike[SupportsNeg[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    def __pos__(self: MatrixLike[SupportsPos[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    def __abs__(self: MatrixLike[SupportsAbs[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    def __invert__(self: MatrixLike[SupportsInvert[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    @overload
    def __matmul__(self: MatrixLike[SupportsDotProduct[T, SupportsMonomorphicAddT], NRowsT_co, InnerT], other: MatrixLike[T, InnerT, NColsT]) -> FrozenMatrix[SupportsMonomorphicAddT, NRowsT_co, NColsT]: ...
    @overload
    def __matmul__(self: MatrixLike[T, NRowsT_co, InnerT], other: MatrixLike[SupportsRDotProduct[T, SupportsMonomorphicAddT], InnerT, NColsT]) -> FrozenMatrix[SupportsMonomorphicAddT, NRowsT_co, NColsT]: ...

    @classmethod
    def wrap(cls: type[FrozenMatrixT], array: MutableSequence[DTypeT_co], shape: Shape[NRowsT_co, NColsT_co]) -> FrozenMatrixT: ...
    @classmethod
    def infer(cls: type[FrozenMatrixT], rows: Iterable[Iterable[DTypeT_co]]) -> FrozenMatrixT: ...

    @property
    def shape(self) -> ShapeView[NRowsT_co, NColsT_co]: ...
    @property
    def nrows(self) -> NRowsT_co: ...
    @property
    def ncols(self) -> NColsT_co: ...
    @property
    def size(self) -> int: ...

    def eq(self, other: MatrixLike[Any, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def ne(self, other: MatrixLike[Any, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def lt(self, other: MatrixLike[DTypeT_co, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def le(self, other: MatrixLike[DTypeT_co, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def gt(self, other: MatrixLike[DTypeT_co, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def ge(self, other: MatrixLike[DTypeT_co, NRowsT_co, NColsT_co]) -> FrozenMatrix[bool, NRowsT_co, NColsT_co]: ...
    def conjugate(self: MatrixLike[SupportsConjugate[T], NRowsT_co, NColsT_co]) -> FrozenMatrix[T, NRowsT_co, NColsT_co]: ...
    @overload
    def slices(self, *, by: Literal[Rule.ROW]) -> Iterator[FrozenMatrix[DTypeT_co, Literal[1], NColsT_co]]: ...
    @overload
    def slices(self, *, by: Literal[Rule.COL]) -> Iterator[FrozenMatrix[DTypeT_co, NRowsT_co, Literal[1]]]: ...
    @overload
    def slices(self, *, by: Rule) -> Iterator[FrozenMatrix[DTypeT_co, int, int]]: ...
    @overload
    def slices(self) -> Iterator[FrozenMatrix[DTypeT_co, Literal[1], NColsT_co]]: ...
