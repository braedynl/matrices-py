import sys
import typing
from collections.abc import Iterable, Iterator, Sequence
from enum import Enum
from typing import Any, Optional, ParamSpec, SupportsIndex, TypeVar

T = TypeVar("T")
S = TypeVar("S")

T1 = TypeVar("T1")
T2 = TypeVar("T2")
T3 = TypeVar("T3")
Tx = TypeVar("Tx")

P = ParamSpec("P")


@typing.final
class Rule(Enum):

    ROW: int
    COL: int

    @property
    def inverse(self) -> Rule: ...
    @property
    def true_name(self) -> str: ...

    def subshape(self, shape: Shape) -> Shape: ...
    def serialize(self, index: int, shape: Shape) -> tuple[int, int, int]: ...
    def range(self, index: int, shape: Shape) -> range: ...
    def slice(self, index: int, shape: Shape) -> slice: ...

    def __index__(self) -> int: ...


@typing.final
class Shape:

    @property
    def data(self) -> list[int]: ...
    @property
    def nrows(self) -> int: ...
    @nrows.setter
    def nrows(self, value: int) -> None: ...
    @property
    def ncols(self) -> int: ...
    @ncols.setter
    def ncols(self, value: int) -> None: ...
    @property
    def size(self) -> int: ...

    def copy(self) -> Shape: ...
    def reverse(self) -> Shape: ...
    def resolve_index(self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def resolve_slice(self, key: slice, *, by: Rule = Rule.ROW) -> range: ...

    def __init__(self, nrows: int = 0, ncols: int = 0) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: SupportsIndex) -> int: ...
    def __setitem__(self, key: SupportsIndex, value: int) -> None: ...
    def __iter__(self) -> Iterator[int]: ...
    def __reversed__(self) -> Iterator[int]: ...
    def __contains__(self, value: Any) -> bool: ...
    def __copy__(self) -> Shape: ...
    def __deepcopy__(self, memo: Optional[dict[int, Any]] = None) -> Shape: ...


class BaseMatrix(Sequence[T]):
    if sys.version_info >= (3, 11):
        Self = typing.Self
    else:
        Self = TypeVar("Self", bound="BaseMatrix[T]")

    @classmethod
    def wrap(cls: type[Self], data: list[T], shape: Shape) -> Self: ...
    @classmethod
    def fill(cls: type[Self], value: T, nrows: int, ncols: int) -> Self: ...
    @classmethod
    def refer(cls: type[Self], other: BaseMatrix[T]) -> Self: ...
    @classmethod
    def infer(cls: type[Self], other: Iterable[Iterable[T]]) -> Self: ...

    @property
    def data(self: Self) -> list[T]: ...
    @property
    def shape(self: Self) -> Shape: ...
    @property
    def size(self: Self) -> int: ...
    @property
    def nrows(self: Self) -> int: ...
    @property
    def ncols(self: Self) -> int: ...

    def index(self: Self, value: T, start: int = 0, stop: Optional[int] = None) -> int: ...
    def count(self: Self, value: T) -> int: ...
    def reshape(self: Self, nrows: int, ncols: int) -> Self: ...
    def slices(self: Self, *, by: Rule = Rule.ROW) -> Iterator[Self]: ...
    def mask(self: Self, selector: BaseMatrix[Any], null: T) -> Self: ...
    def replace(self: Self, old: T, new: T, *, times: Optional[int] = None) -> Self: ...
    def reverse(self: Self) -> Self: ...
    def swap(self: Self, key1: SupportsIndex, key2: SupportsIndex, *, by: Rule = Rule.ROW) -> Self: ...
    def flip(self: Self, *, by: Rule = Rule.ROW) -> Self: ...
    def flatten(self: Self, *, by: Rule = Rule.ROW) -> Self: ...
    def transpose(self: Self) -> Self: ...
    def stack(self: Self, other: Sequence[T], *, by: Rule = Rule.ROW) -> Self: ...
    def pull(self: Self, key: SupportsIndex = -1, *, by: Rule = Rule.ROW) -> Self: ...
    def copy(self: Self, *, deep: bool = False) -> Self: ...

    def __init__(self: Self, values: Iterable[T], nrows: int, ncols: int) -> None: ...
    def __repr__(self: Self) -> str: ...
    def __str__(self: Self) -> str: ...

    # These two operators will always return a BaseMatrix since you're allowed
    # to return other objects in their overloads (i.e., you're not guaranteed a
    # matrix of booleans). This is specified by the official data model, but
    # conflicts with object's definition
    def __eq__(self: Self, other: BaseMatrix[Any]) -> BaseMatrix[Any]: ...  # type: ignore[override]
    def __ne__(self: Self, other: BaseMatrix[Any]) -> BaseMatrix[Any]: ...  # type: ignore[override]

    def __len__(self: Self) -> int: ...

    @typing.overload
    def __getitem__(self: Self, key: SupportsIndex) -> T: ...
    @typing.overload
    def __getitem__(self: Self, key: slice) -> Self: ...
    @typing.overload
    def __getitem__(self: Self, key: tuple[SupportsIndex, SupportsIndex]) -> T: ...
    @typing.overload
    def __getitem__(self: Self, key: tuple[SupportsIndex, slice]) -> Self: ...
    @typing.overload
    def __getitem__(self: Self, key: tuple[slice, SupportsIndex]) -> Self: ...
    @typing.overload
    def __getitem__(self: Self, key: tuple[slice, slice]) -> Self: ...

    @typing.overload
    def __setitem__(self: Self, key: SupportsIndex, value: T) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: slice, value: Sequence[T]) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: tuple[SupportsIndex, SupportsIndex], value: T) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: tuple[SupportsIndex, slice], value: Sequence[T]) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: tuple[slice, SupportsIndex], value: Sequence[T]) -> None: ...
    @typing.overload
    def __setitem__(self: Self, key: tuple[slice, slice], value: Sequence[T]) -> None: ...

    def __iter__(self: Self) -> Iterator[T]: ...
    def __reversed__(self: Self) -> Iterator[T]: ...
    def __contains__(self: Self, value: Any) -> bool: ...
    def __copy__(self: Self) -> Self: ...
    def __deepcopy__(self: Self, memo: Optional[dict[int, Any]] = None) -> Self: ...
